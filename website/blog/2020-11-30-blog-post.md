---
title: Introducing the Chaos compiler
author: M. Mert Yildiran
authorURL: https://mertyildiran.com/
---

The Chaos language had already a fully functional interpreter to this point.
But for the sake of standalone application development and performance improvements,
I have decided to implement a compiler alongside the interpreter and started to
develop the compiler on September 23, 2020 with [this commit](https://github.com/chaos-lang/chaos/commit/af621014bda40edb8247109269e495ecc3b8d4dd).
Today I would like to introduce you the first official release `v0.1.0` of the Chaos language and talk about
the details of the Chaos compiler.

## The Code

First of all, let's say the **hello.kaos** file is:

```chaos
print "hello world"
```

so you compile this program with:

```shell
$ chaos -c hello.kaos -o hello
Starting compiling...
Compiling Chaos code into build/hello.c
Compiling the C code into machine code...
Cleaning up the temporary files...

Finished compiling.

Binary is ready on: build/hello
$ build/hello
hello world
```

if you compile this file with the `-k` option like: `chaos -c hello.kaos -o hello -k` it will not remove (**keep**) the
intermediate C source code so you can take a look at the generated C code with `cat build/hello.c`:

```c
/*
 * Intermediate C source code generated by Chaos Programming Language
 * Language Reference: https://chaos-lang.org
 *
 * Filename: hello.c
 */

#include "hello.h"

extern bool disable_complex_mode;

int kaos_lineno;
bool is_interactive = false;
unsigned long long nested_loop_counter = 0;
const long double inf = 1.0 / 0.0;

int main(int argc, char** argv) {
    program_file_path = malloc(strlen("hello.kaos") + 1);
    strcpy(program_file_path, "hello.kaos");
    char *argv0 = malloc(1 + strlen(argv[0]));
    strcpy(argv0, argv[0]);
    initMainFunction();
    Symbol* symbol;
    long long exit_code;
    phase = PREPARSE;
    phase = PROGRAM;
    kaos_lineno = 0;
    printf("hello world\n");
    free(argv0);
    freeEverything(argv0);
    return 0;
}
```

and the header file:

```c
/*
 * Intermediate C header code generated by Chaos Programming Language
 * Language Reference: https://chaos-lang.org
 *
 * Filename: hello.h
 */

#ifndef HELLO_H
#define HELLO_H

#include <stdio.h>
#include <stdbool.h>

#include "interpreter/function.h"
#include "interpreter/symbol.h"

unsigned long long nested_loop_counter;
jmp_buf LoopBreak;
jmp_buf LoopContinue;


#endif
```

At the first glance, it might look like an overkill for a "Hello, World!" program but when you consider the fact
that Chaos is a high-level programming language, it's actually a short code.

## The Size

When you look at the size of this binary:

```shell
$ stat -c %s build/hello
262648
```

it's 260 KB. So it can be said that a program in Chaos can only be that small.

You might wonder the reason; while the "Hello, World!" in C:

```c
#include <stdio.h>

int main() {
   printf("hello world\n");
   return 0;
}
```

is only 16 KB, why the same program in Chaos is 260 KB in size. The answer is; Chaos programs are compiled against
[the language's source](https://github.com/chaos-lang/chaos). So that it **packs the Chaos runtime** into
the compiled binary. That's why it's a little bit bigger in size.

The one aspect of Chaos language that enables shipping the runtime with every compiled program is; the language's
source is designed with the mindset that every library, even the core libraries, will be **shipped separately** and will
not be included in [the language's source](https://github.com/chaos-lang/chaos). With this way,
bloated code is prevented and the language's size is reduced significantly.

If you're still not convinced about the necessity of shipping the language with the program, I urge you to write
the **equivalent** of this [`list.kaos`](https://github.com/chaos-lang/chaos/blob/v0.1.0/tests/list.kaos) (291 KB)
example in **C language** and look at the size of your binary. You'll see that it does not worth to write it in C.
It's also possible that you can increase the size while trying to do it in C.

## The Performance

[`everything.kaos`](https://github.com/chaos-lang/chaos/blob/v0.1.0/tests/everything.kaos) is a pretty suitable example
that demonstrates almost all of the features of the language in a single short program. You compile this program with
`chaos -c tests/everything.kaos -o everything` and then when you look at the time statistics:

Interpreted:

```shell
$ time chaos tests/everything.kaos
real    0m0,005s
user    0m0,001s
sys     0m0,005s
```

Compiled:

```shell
$ time build/everything
real    0m0,004s
user    0m0,001s
sys     0m0,003s
```

The compiled program is almost 50% faster than the interpreted program. The reason for this performance improvement is;
neither the **[lexer](https://github.com/chaos-lang/chaos/blob/v0.1.0/lexer/lexer.l)**
nor the **[parser](https://github.com/chaos-lang/chaos/blob/v0.1.0/parser/parser.y)** is executed while running the
compiled program.

The peak memory usage is also slightly lower in case of the compiled program. The peak memory usage statistics:

- Interpreted: `Maximum resident set size (kbytes): 2552`
- Compiled: `Maximum resident set size (kbytes): 2308`

Because of these performance advantages, it's highly recommended to use the compiled version of your program
in the production environment. Chaos has the interpreter and the REPL (read–eval–print loop) options to speed up
your development process while slowing down your runtime. The outcome of the compiled and the interpreted programs
are and will always be identical.

## The Extra

The Chaos binary has a flag `-e, --extra` to inject extra flags into C compiler command for advanced users. With this
flag you can increase your debugging posiblities. Here are some examples:

GNU Debugger:

```shell
chaos -c hello.kaos -o hello -e "-ggdb"
```

Clang MemorySanitizer (MSan):

```shell
chaos -c hello.kaos -o hello -e "-fsanitize=memory -fsanitize-memory-track-origins=2 -O1 -fno-optimize-sibling-calls -ggdb"
```

Clang AddressSanitizer (ASan):

```shell
chaos -c hello.kaos -o hello -e "-fsanitize=address -fno-omit-frame-pointer -g -ggdb"
```

Clang UndefinedBehaviorSanitizer (UBSan):

```shell
chaos -c hello.kaos -o hello -e "-fsanitize=undefined -ggdb"
```

> Note: Clang sanitizers require your Chaos binary to be compiled with `clang` instead of `gcc`. So make sure that
> you have compiled Chaos from [its source](https://github.com/chaos-lang/chaos) with `make clang` command.
